using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ReactiveGenerator;

[Generator]
public class ReactiveCommandGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Ensure attribute source is added (if attribute isn't in your codebase).
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateCommandAttribute.g.cs", SourceText.From(EmbeddedAttributeSource, Encoding.UTF8));
        });

        // Syntax provider: filter for methods with [GenerateCommandAttribute].
        var methodsWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => HasGenerateCommandAttribute(node),
                transform: static (ctx, _) => GetMethodSymbol(ctx))
            .Where(symbol => symbol is not null);

        // Combine with compilation so we can do deeper analysis if needed
        var compilationAndMethods = context.CompilationProvider.Combine(methodsWithAttribute.Collect());

        // Register final source output
        context.RegisterSourceOutput(compilationAndMethods, static (spc, source) =>
        {
            var (compilation, methodSymbols) = source;

            // Group methods by their containing class
            var methodsByType = methodSymbols!
                .GroupBy(m => m.ContainingType, SymbolEqualityComparer.Default);

            foreach (var group in methodsByType)
            {
                // Each group represents a partial class that has 1..N annotated methods
                var typeSymbol = (INamedTypeSymbol)group.Key;
                var generatedSource = GeneratePartialForCommands(compilation, typeSymbol, group.ToList());

                // If there's at least one command to generate, add the source
                if (!string.IsNullOrWhiteSpace(generatedSource))
                {
                    var hintName = GetSafeFileName($"{typeSymbol.ToDisplayString()}.ReactiveCommands.g.cs");
                    spc.AddSource(hintName, SourceText.From(generatedSource, Encoding.UTF8));
                }
            }
        });
    }

    private static bool HasGenerateCommandAttribute(SyntaxNode node)
    {
        // We only care about method declarations that have attribute lists
        if (node is MethodDeclarationSyntax methodDecl && methodDecl.AttributeLists.Count > 0)
        {
            // Quick textual check (faster than semantic check)
            return methodDecl.AttributeLists
                .SelectMany(a => a.Attributes)
                .Any(a => a.Name.ToString().Contains("GenerateCommand"));
        }
        return false;
    }

    private static IMethodSymbol? GetMethodSymbol(GeneratorSyntaxContext context)
    {
        if (context.Node is not MethodDeclarationSyntax methodDecl)
            return null;

        // Get the symbol
        var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
        if (methodSymbol == null)
            return null;

        // Check if actually has [GenerateCommandAttribute]
        var hasAttr = methodSymbol.GetAttributes()
            .Any(ad => ad.AttributeClass?.Name == "GenerateCommandAttribute");
        return hasAttr ? methodSymbol : null;
    }

    private static string GeneratePartialForCommands(
        Compilation compilation,
        INamedTypeSymbol typeSymbol,
        List<IMethodSymbol> methods)
    {
        // We'll build everything in a single partial class
        var sb = new StringBuilder();
        var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : typeSymbol.ContainingNamespace.ToString();

        // Prepare partial class signature
        var containingTypes = GetContainingTypes(typeSymbol);
        var typeDeclaration = GetTypeDeclarationString(typeSymbol, out var typeConstraints);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using ReactiveUI;");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Reactive;");
        sb.AppendLine("using System.Reactive.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        // Open any containing (nested) types
        foreach (var ct in containingTypes)
        {
            sb.AppendLine($"partial {ct.Declaration}");
            sb.AppendLine("{");
        }

        // We explicitly enforce "public partial class" here. 
        // If you want to respect the original accessibility, you could adapt accordingly.
        sb.AppendLine($"public partial {typeDeclaration} {typeConstraints}");
        sb.AppendLine("{");

        // Generate the command properties with inline initialization
        foreach (var methodSymbol in methods)
        {
            var propertyDecl = GenerateCommandPropertyDeclaration(compilation, methodSymbol);
            sb.AppendLine(propertyDecl);
        }

        sb.AppendLine("}"); // close the partial class

        // Close containing types
        for (int i = containingTypes.Count - 1; i >= 0; i--)
        {
            sb.AppendLine("}");
        }

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GenerateCommandPropertyDeclaration(Compilation compilation, IMethodSymbol methodSymbol)
    {
        var attrData = methodSymbol.GetAttributes()
            .First(ad => ad.AttributeClass?.Name == "GenerateCommandAttribute");
        var commandName = GetCommandPropertyName(methodSymbol, attrData);

        // Figure out the can-execute expression
        var canExecuteExpr = BuildCanExecuteExpression(methodSymbol.ContainingType, attrData, compilation);

        // Infer <TParam, TResult> from method signature
        InferCommandTypes(methodSymbol, attrData, out var paramType, out var resultType);

        // Build the ReactiveCommand creation expression
        var creationExpr = BuildReactiveCommandCreationExpression(
            methodSymbol, paramType, resultType, canExecuteExpr);

        // Example:
        // public ReactiveCommand<ParamType, ResultType> MyCommand { get; } =
        //     ReactiveCommand.Create...(...);
        var propertyCode = $@"
    public ReactiveCommand<{paramType}, {resultType}> {commandName} {{ get; }} 
        = {creationExpr};";

        return propertyCode;
    }

private static string BuildReactiveCommandCreationExpression(
    IMethodSymbol methodSymbol,
    string paramType,         // e.g. "Unit"
    string resultType,        // e.g. "Unit"
    string canExecuteExpr)
{
    var returnType = methodSymbol.ReturnType;
    var methodName = methodSymbol.Name;

    bool isAsync = IsTaskLikeType(returnType);
    bool isObservable = IsIObservableType(returnType);

    // If there's a can-execute expression, weâ€™ll add it last
    string commaCanExec = string.IsNullOrEmpty(canExecuteExpr) ? "" : $", {canExecuteExpr}";

    // ### 1) Method has 0 parameters?
    if (methodSymbol.Parameters.Length == 0)
    {
        // Synchronous
        if (!isAsync && !isObservable)
        {
            // => ReactiveCommand.Create(() => MyMethod(), canExecute);
            return $"ReactiveCommand.Create(() => {methodName}(){commaCanExec})";
        }
        // Async => Task or Task<T>
        else if (isAsync)
        {
            // => ReactiveCommand.CreateFromTask(() => MyAsyncMethod(), canExecute);
            return $"ReactiveCommand.CreateFromTask(() => {methodName}(){commaCanExec})";
        }
        // IObservable
        else
        {
            // => ReactiveCommand.CreateFromObservable(() => MyObservableMethod(), canExecute);
            return $"ReactiveCommand.CreateFromObservable(() => {methodName}(){commaCanExec})";
        }
    }

    // ### 2) Method has exactly 1 parameter?
    else if (methodSymbol.Parameters.Length == 1)
    {
        string paramName = methodSymbol.Parameters[0].Name; // e.g. x => MyMethod(x)

        if (!isAsync && !isObservable)
        {
            // => ReactiveCommand.Create<TParam, Unit>(x => {methodName}(x), canExecute);
            return $"ReactiveCommand.Create<{paramType}, {resultType}>({paramName} => {methodName}({paramName}){commaCanExec})";
        }
        else if (isAsync)
        {
            // => ReactiveCommand.CreateFromTask<TParam, TResult>(x => MyMethodAsync(x), canExecute);
            return $"ReactiveCommand.CreateFromTask<{paramType}, {resultType}>({paramName} => {methodName}({paramName}){commaCanExec})";
        }
        else
        {
            // => ReactiveCommand.CreateFromObservable<TParam, TResult>(x => MyObservableMethod(x), canExecute);
            return $"ReactiveCommand.CreateFromObservable<{paramType}, {resultType}>({paramName} => {methodName}({paramName}){commaCanExec})";
        }
    }

    // ### 3) More than 1 parameter => out of scope, or you handle via aggregator, etc.
    return "// TODO: More than 1 param not currently supported.";
}


    private static string BuildCanExecuteExpression(
        INamedTypeSymbol containingType,
        AttributeData attrData,
        Compilation compilation)
    {
        // If CanExecuteProperty is a bool property => use: this.WhenAnyValue(x => x.CanExecuteProperty)
        // If it's an IObservable<bool>, we can use that directly
        // If not provided, return ""

        var canExecuteProperty = GetNamedArg<string>(attrData, "CanExecuteProperty");
        if (string.IsNullOrEmpty(canExecuteProperty))
            return "";

        var members = containingType.GetMembers(canExecuteProperty);
        if (members.Length > 0)
        {
            var member = members[0];
            switch (member)
            {
                case IPropertySymbol propSymbol:
                    if (propSymbol.Type.SpecialType == SpecialType.System_Boolean)
                        return $"this.WhenAnyValue(x => x.{canExecuteProperty})";
                    if (IsIObservableOfBool(propSymbol.Type))
                        return canExecuteProperty; 
                    break;
                case IFieldSymbol fieldSymbol:
                    if (IsIObservableOfBool(fieldSymbol.Type))
                        return canExecuteProperty;
                    // If it's bool -> typically we do WhenAnyValue, but that only works if it's properly raising changes.
                    break;
                case IMethodSymbol methodSym:
                    if (IsIObservableOfBool(methodSym.ReturnType))
                        return $"{canExecuteProperty}()";
                    break;
            }
        }

        // fallback
        return "";
    }

    private static bool IsIObservableOfBool(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol namedType &&
            namedType.IsGenericType &&
            namedType.TypeArguments.Length == 1 &&
            namedType.Name == "IObservable")
        {
            var arg = namedType.TypeArguments[0];
            return arg.SpecialType == SpecialType.System_Boolean;
        }
        return false;
    }

    private static void InferCommandTypes(
        IMethodSymbol methodSymbol,
        AttributeData attrData,
        out string paramType,
        out string resultType)
    {
        // Default is <Unit, Unit>
        paramType = "Unit";
        resultType = "Unit";

        // If user gave ParameterType in attribute, override paramType
        var specifiedParamType = GetNamedArg<INamedTypeSymbol>(attrData, "ParameterType");
        if (specifiedParamType != null)
        {
            paramType = specifiedParamType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }
        else if (methodSymbol.Parameters.Length == 1)
        {
            // use the method param as the command param type
            paramType = methodSymbol.Parameters[0].Type
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        // Now figure out the result type
        if (IsTaskLikeType(methodSymbol.ReturnType))
        {
            // If it's Task<T>, result = T
            // If it's Task (no T), result = Unit
            if (methodSymbol.ReturnType is INamedTypeSymbol named && 
                named.IsGenericType && 
                named.Name == "Task")
            {
                var tArg = named.TypeArguments[0];
                resultType = tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
        }
        else if (IsIObservableType(methodSymbol.ReturnType))
        {
            // If it's IObservable<T>, result = T
            if (methodSymbol.ReturnType is INamedTypeSymbol named && 
                named.IsGenericType && 
                named.Name == "IObservable")
            {
                var tArg = named.TypeArguments[0];
                resultType = tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
            else
            {
                resultType = "object";
            }
        }
    }

    private static bool IsTaskLikeType(ITypeSymbol typeSymbol)
    {
        if (typeSymbol == null) return false;
        return typeSymbol.Name == "Task" && typeSymbol.ContainingNamespace.ToString() == "System.Threading.Tasks";
    }

    private static bool IsIObservableType(ITypeSymbol typeSymbol)
    {
        if (typeSymbol == null) return false;
        return typeSymbol.Name == "IObservable";
    }

    private static T? GetNamedArg<T>(AttributeData attrData, string propertyName)
    {
        // Looks for [GenerateCommandAttribute(PropertyName = ???)]
        var namedArg = attrData.NamedArguments
            .FirstOrDefault(na => na.Key == propertyName);

        if (namedArg.Key == null) return default;
        if (namedArg.Value.Value is T tValue)
            return tValue;
        return default;
    }

    private static string GetCommandPropertyName(IMethodSymbol methodSymbol, AttributeData attrData)
    {
        var commandName = GetNamedArg<string>(attrData, "CommandName");
        if (!string.IsNullOrEmpty(commandName))
            return commandName;

        // fallback => <MethodName>Command
        return methodSymbol.Name + "Command";
    }

    private static string GetTypeDeclarationString(INamedTypeSymbol typeSymbol, out string constraints)
    {
        // e.g. "class MyViewModel<T>" plus constraints
        // We explicitly do 'public partial class' here:
        var typeParams = typeSymbol.TypeParameters;
        var className = typeSymbol.Name;
        var partialDecl = $"class {className}";

        if (typeParams.Length == 0)
        {
            constraints = string.Empty;
            return partialDecl;
        }

        // If there are generic type parameters
        var tpList = "<" + string.Join(", ", typeParams.Select(tp => tp.Name)) + ">";
        var sbConstraints = new StringBuilder();
        foreach (var tp in typeParams)
        {
            var constraintClauses = new List<string>();
            if (tp.HasReferenceTypeConstraint)
                constraintClauses.Add("class");
            if (tp.HasUnmanagedTypeConstraint)
                constraintClauses.Add("unmanaged");
            if (tp.HasValueTypeConstraint && !tp.HasUnmanagedTypeConstraint)
                constraintClauses.Add("struct");
            if (tp.HasConstructorConstraint)
                constraintClauses.Add("new()");

            foreach (var t in tp.ConstraintTypes)
            {
                constraintClauses.Add(t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            }
            if (constraintClauses.Count > 0)
            {
                sbConstraints.AppendLine($"    where {tp.Name} : {string.Join(", ", constraintClauses)}");
            }
        }

        constraints = sbConstraints.ToString();
        return partialDecl + tpList;
    }

    private static List<(string Declaration, INamedTypeSymbol Symbol)> GetContainingTypes(INamedTypeSymbol typeSymbol)
    {
        // For any nesting...
        var result = new List<(string Declaration, INamedTypeSymbol Symbol)>();
        var current = typeSymbol.ContainingType;
        while (current != null)
        {
            var dec = $"partial class {current.Name}";
            result.Add((dec, current));
            current = current.ContainingType;
        }
        result.Reverse();
        return result;
    }

    private static string GetSafeFileName(string name)
    {
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        foreach (var c in invalid)
        {
            name = name.Replace(c, '_');
        }
        return name;
    }

    private const string EmbeddedAttributeSource = @"// <auto-generated/>
using System;

enum CommandCreationType
{
    Create,
    FromTask,
    FromObservable
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
sealed class GenerateCommandAttribute : Attribute
{
    public string? CommandName { get; set; }
    public string? CanExecuteProperty { get; set; }
    public CommandCreationType? CommandType { get; set; }
    public Type? ParameterType { get; set; }
}
";
}
