using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ReactiveGenerator;

[Generator]
public class ReactiveCommandGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Ensure attribute source is added (if attribute isn't in your codebase).
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateCommandAttribute.g.cs", SourceText.From(EmbeddedAttributeSource, Encoding.UTF8));
        });

        // Syntax provider: filter for methods with [GenerateCommandAttribute].
        var methodsWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => HasGenerateCommandAttribute(node),
                transform: static (ctx, _) => GetMethodSymbol(ctx))
            .Where(symbol => symbol is not null);

        // Combine with compilation so we can do deeper analysis if needed
        var compilationAndMethods = context.CompilationProvider.Combine(methodsWithAttribute.Collect());

        // Register final source output
        context.RegisterSourceOutput(compilationAndMethods, static (spc, source) =>
        {
            var (compilation, methodSymbols) = source;

            // Group methods by their containing class
            var methodsByType = methodSymbols!
                .GroupBy(m => m.ContainingType, SymbolEqualityComparer.Default);

            foreach (var group in methodsByType)
            {
                // Each group represents a partial class that has 1..N annotated methods
                var typeSymbol = (INamedTypeSymbol)group.Key;
                var generatedSource = GeneratePartialForCommands(compilation, typeSymbol, group.ToList());

                // If there's at least one command to generate, add the source
                if (!string.IsNullOrWhiteSpace(generatedSource))
                {
                    var hintName = GetSafeFileName($"{typeSymbol.ToDisplayString()}.ReactiveCommands.g.cs");
                    spc.AddSource(hintName, SourceText.From(generatedSource, Encoding.UTF8));
                }
            }
        });
    }

    private static bool HasGenerateCommandAttribute(SyntaxNode node)
    {
        // We only care about method declarations that have attribute lists
        if (node is MethodDeclarationSyntax methodDecl && methodDecl.AttributeLists.Count > 0)
        {
            // Quick textual check (faster than semantic check)
            return methodDecl.AttributeLists
                .SelectMany(a => a.Attributes)
                .Any(a => a.Name.ToString().Contains("GenerateCommand"));
        }
        return false;
    }

    private static IMethodSymbol? GetMethodSymbol(GeneratorSyntaxContext context)
    {
        if (context.Node is not MethodDeclarationSyntax methodDecl)
            return null;

        // Get the symbol
        var methodSymbol = context.SemanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
        if (methodSymbol == null)
            return null;

        // Check if actually has [GenerateCommandAttribute]
        var hasAttr = methodSymbol.GetAttributes()
            .Any(ad => ad.AttributeClass?.Name == "GenerateCommandAttribute");
        return hasAttr ? methodSymbol : null;
    }

    private static string GeneratePartialForCommands(
        Compilation compilation,
        INamedTypeSymbol typeSymbol,
        List<IMethodSymbol> methods)
    {
        // We'll build everything in a single partial class
        var sb = new StringBuilder();
        var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : typeSymbol.ContainingNamespace.ToString();

        // Prepare partial class signature
        var containingTypes = GetContainingTypes(typeSymbol);
        var typeDeclaration = GetTypeDeclarationString(typeSymbol, out var typeConstraints);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using ReactiveUI;");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Reactive;");
        sb.AppendLine("using System.Reactive.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        // Open containing type declarations
        foreach (var ct in containingTypes)
        {
            sb.AppendLine($"partial {ct.Declaration}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"partial {typeDeclaration} {typeConstraints}");
        sb.AppendLine("{");

        // We’ll generate a partial constructor or partial method to init commands
        // Option A: partial constructor
        // Option B: partial void InitializeCommands()
        // Here we go with a partial constructor approach for clarity
        var constructorName = typeSymbol.Name;
        sb.AppendLine($"    public partial {constructorName}()");
        sb.AppendLine("    {");
        sb.AppendLine("        InitializeGeneratedCommands();");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private void InitializeGeneratedCommands()");
        sb.AppendLine("    {");

        foreach (var methodSymbol in methods)
        {
            var cmdSetup = GenerateCommandForMethod(compilation, methodSymbol);
            sb.AppendLine(cmdSetup);
        }

        sb.AppendLine("    }"); // End InitializeGeneratedCommands
        sb.AppendLine();

        // Generate properties
        foreach (var methodSymbol in methods)
        {
            var propertyDecl = GenerateCommandPropertyDeclaration(methodSymbol);
            sb.AppendLine(propertyDecl);
        }

        sb.AppendLine("}"); // close the partial class

        // Close containing types
        for (int i = containingTypes.Count - 1; i >= 0; i--)
        {
            sb.AppendLine("}");
        }

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GenerateCommandPropertyDeclaration(IMethodSymbol methodSymbol)
    {
        var attrData = methodSymbol.GetAttributes()
            .First(ad => ad.AttributeClass?.Name == "GenerateCommandAttribute");

        var commandName = GetCommandPropertyName(methodSymbol, attrData);

        // Determine <TParam, TResult> from method signature
        // - If method has exactly 1 parameter and returns Task or void, TParam = param type, TResult = Unit
        // - If method returns Task<T>, TParam = param type (or Unit if none), TResult = T
        // - If method returns IObservable<T>, TParam = param type (or Unit), TResult = T
        // etc.

        InferCommandTypes(methodSymbol, attrData, out var paramType, out var resultType);
        return
            $@"    public ReactiveCommand<{paramType}, {resultType}> {commandName} {{ get; private set; }}";
    }

    private static string GenerateCommandForMethod(Compilation compilation, IMethodSymbol methodSymbol)
    {
        var attrData = methodSymbol.GetAttributes()
            .First(ad => ad.AttributeClass?.Name == "GenerateCommandAttribute");

        var commandName = GetCommandPropertyName(methodSymbol, attrData);

        // Figure out can-execute observable or property
        var canExecuteExpr = BuildCanExecuteExpression(methodSymbol.ContainingType, attrData, compilation);

        // Command creation logic
        // We either do:
        // 1. ReactiveCommand.Create(...)         for void method
        // 2. ReactiveCommand.CreateFromTask(...) for Task method
        // 3. ReactiveCommand.CreateFromObservable(...) for IObservable method
        // We also handle param methods if needed (methodSymbol.Parameters)

        InferCommandTypes(methodSymbol, attrData, out var paramType, out var resultType);

        var commandExpression = BuildReactiveCommandCreationExpression(
            methodSymbol, paramType, resultType, canExecuteExpr);

        return
            $@"        this.{commandName} = {commandExpression};";
    }

    private static string BuildReactiveCommandCreationExpression(
        IMethodSymbol methodSymbol,
        string paramType,
        string resultType,
        string canExecuteExpr)
    {
        // If method is void or returns a non-async type, we can do ReactiveCommand.Create(...)
        // If method returns Task or Task<T>, do CreateFromTask
        // If returns IObservable<T>, do CreateFromObservable

        var returnType = methodSymbol.ReturnType;
        var methodName = methodSymbol.Name;
        var paramSignature = string.Join(", ",
            methodSymbol.Parameters.Select(p => p.Name));

        // If methodSymbol.Parameters.Count == 0 => no param
        // Otherwise we pass the param: x => methodSymbolName(x)

        var isAsync = IsTaskLikeType(returnType);
        var isObservable = IsIObservableType(returnType);

        // Build the lambda
        // For a method with no parameters, we do () => Method() or () => MethodAsync()
        // For a method with 1 parameter, we do x => Method(x)
        // For multiple parameters, we'd need a custom strategy, but let's keep it simpler here.
        string execLambda;
        if (methodSymbol.Parameters.Length == 0)
        {
            if (isAsync)
            {
                // async
                // CreateFromTask(() => methodSymbol())
                execLambda = $"() => {methodName}()";
            }
            else if (isObservable)
            {
                // CreateFromObservable(() => methodSymbol())
                execLambda = $"() => {methodName}()";
            }
            else
            {
                // synchronous
                execLambda = $"() => {methodName}()";
            }
        }
        else if (methodSymbol.Parameters.Length == 1)
        {
            var paramName = methodSymbol.Parameters[0].Name;
            // e.g. x => methodName(x)
            // if async => CreateFromTask((x) => methodSymbol(x))
            // if observable => CreateFromObservable((x) => methodSymbol(x))
            // synchronous => Create((x) => methodSymbol(x))
            execLambda = $"{paramName} => {methodName}({paramName})";
        }
        else
        {
            // For demonstration, we’ll just handle up to 1 param. 
            // If you want to handle multiple, you'd create a small record or tuple
            // or generate an aggregator. That is more advanced.
            // We'll produce an error expression or comment for now.
            return "// ERROR: More than one parameter not handled automatically by the generator.\n" +
                   "ReactiveCommand.Create(() => { })";
        }

        // Build the actual call
        // Synchronous: Create<TParam, TResult>(execLambda, canExecuteExpr)
        // Async: CreateFromTask<TParam, TResult>(execLambda, canExecuteExpr)
        // Observable: CreateFromObservable<TParam, TResult>(execLambda, canExecuteExpr)

        var paramResult = $"<{paramType}, {resultType}>";
        if (isAsync)
        {
            return
                $"ReactiveCommand.CreateFromTask{paramResult}({execLambda}{(string.IsNullOrEmpty(canExecuteExpr) ? "" : ", " + canExecuteExpr)})";
        }
        else if (isObservable)
        {
            return
                $"ReactiveCommand.CreateFromObservable{paramResult}({execLambda}{(string.IsNullOrEmpty(canExecuteExpr) ? "" : ", " + canExecuteExpr)})";
        }
        else
        {
            // synchronous
            return
                $"ReactiveCommand.Create{paramResult}({execLambda}{(string.IsNullOrEmpty(canExecuteExpr) ? "" : ", " + canExecuteExpr)})";
        }
    }

    private static string BuildCanExecuteExpression(
        INamedTypeSymbol containingType,
        AttributeData attrData,
        Compilation compilation)
    {
        // If CanExecuteProperty is a bool property => use: this.WhenAnyValue(x => x.CanExecuteProperty)
        // If it's an IObservable<bool>, we can use that directly: e.g. someObservableBool
        // If not provided, return ""
        var canExecuteProperty = GetNamedArg<string>(attrData, "CanExecuteProperty");
        if (string.IsNullOrEmpty(canExecuteProperty))
            return "";

        // We check if there's a member with that name. 
        // If it's a property of type bool, let's do: 
        //    this.WhenAnyValue(x => x.CanExecuteProperty)
        // If it's a property or field of type IObservable<bool>, we use it directly.
        // If we can't find it or it's not recognized, we fallback or throw.

        var members = containingType.GetMembers(canExecuteProperty);
        if (members.Length > 0)
        {
            var member = members[0];
            switch (member)
            {
                case IPropertySymbol propSymbol:
                {
                    // If it's bool => WhenAnyValue
                    // If it's IObservable<bool> => direct
                    if (propSymbol.Type.SpecialType == SpecialType.System_Boolean)
                        return $"this.WhenAnyValue(x => x.{canExecuteProperty})";
                    if (IsIObservableOfBool(propSymbol.Type))
                        return canExecuteProperty; // assume it's used directly
                    break;
                }
                case IFieldSymbol fieldSymbol:
                {
                    // If it's IObservable<bool>, use directly
                    if (IsIObservableOfBool(fieldSymbol.Type))
                        return canExecuteProperty;
                    // If it's bool => we do the same approach as property, but might want to do a WhenAnyValue if it's public
                    break;
                }
                case IMethodSymbol methodSym:
                {
                    // If method returns IObservable<bool>, use it directly
                    if (IsIObservableOfBool(methodSym.ReturnType))
                        return $"{canExecuteProperty}()";
                    break;
                }
            }
        }

        // fallback or none
        return "";
    }

    private static bool IsIObservableOfBool(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol namedType &&
            namedType.IsGenericType &&
            namedType.TypeArguments.Length == 1 &&
            namedType.Name == "IObservable")
        {
            var arg = namedType.TypeArguments[0];
            return arg.SpecialType == SpecialType.System_Boolean;
        }
        return false;
    }

    private static void InferCommandTypes(
        IMethodSymbol methodSymbol,
        AttributeData attrData,
        out string paramType,
        out string resultType)
    {
        // Default is <Unit, Unit>
        paramType = "Unit";
        resultType = "Unit";

        // If user gave ParameterType in attribute, override paramType
        var specifiedParamType = GetNamedArg<INamedTypeSymbol>(attrData, "ParameterType");
        if (specifiedParamType != null)
        {
            paramType = specifiedParamType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }
        else if (methodSymbol.Parameters.Length == 1)
        {
            // use the method param as the command param type
            paramType = methodSymbol.Parameters[0].Type
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        // Now figure out the result type
        if (IsTaskLikeType(methodSymbol.ReturnType))
        {
            // If it's Task<T>, result = T
            // If it's Task (no T), result = Unit
            if (methodSymbol.ReturnType is INamedTypeSymbol named && named.IsGenericType && named.Name == "Task")
            {
                var tArg = named.TypeArguments[0];
                resultType = tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
        }
        else if (IsIObservableType(methodSymbol.ReturnType))
        {
            // If it's IObservable<T>, result = T
            // If it's IObservable with no T -> object
            if (methodSymbol.ReturnType is INamedTypeSymbol named && named.IsGenericType && named.Name == "IObservable")
            {
                var tArg = named.TypeArguments[0];
                resultType = tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
            else
            {
                resultType = "object";
            }
        }
    }

    private static bool IsTaskLikeType(ITypeSymbol typeSymbol)
    {
        if (typeSymbol == null) return false;
        // Check if it's Task or Task<T>
        return typeSymbol.Name == "Task" && typeSymbol.ContainingNamespace.ToString() == "System.Threading.Tasks";
    }

    private static bool IsIObservableType(ITypeSymbol typeSymbol)
    {
        if (typeSymbol == null) return false;
        // check if it's IObservable<T> or IObservable
        return typeSymbol.Name == "IObservable";
    }

    private static T? GetNamedArg<T>(AttributeData attrData, string propertyName)
    {
        // Looks for [GenerateCommandAttribute(PropertyName = ???)]
        var namedArg = attrData.NamedArguments
            .FirstOrDefault(na => na.Key == propertyName);

        if (namedArg.Key == null) return default;
        if (namedArg.Value.Value is T tValue)
            return tValue;
        return default;
    }

    private static string GetCommandPropertyName(IMethodSymbol methodSymbol, AttributeData attrData)
    {
        var commandName = GetNamedArg<string>(attrData, "CommandName");
        if (!string.IsNullOrEmpty(commandName))
            return commandName;

        // fallback to MethodName + "Command"
        return methodSymbol.Name + "Command";
    }

    // Helper: Construct partial type declaration from symbol
    private static string GetTypeDeclarationString(INamedTypeSymbol typeSymbol, out string constraints)
    {
        // e.g. "class MyViewModel<T>" plus constraints
        var typeParams = typeSymbol.TypeParameters;
        if (typeParams.Length == 0)
        {
            constraints = string.Empty;
            return $"{GetAccessibility(typeSymbol)} class {typeSymbol.Name}";
        }

        var tpList = "<" + string.Join(", ", typeParams.Select(tp => tp.Name)) + ">";
        var sbConstraints = new StringBuilder();
        foreach (var tp in typeParams)
        {
            var constraintClauses = new List<string>();
            // generic constraints
            if (tp.HasReferenceTypeConstraint)
                constraintClauses.Add("class");
            if (tp.HasUnmanagedTypeConstraint)
                constraintClauses.Add("unmanaged");
            if (tp.HasValueTypeConstraint && !tp.HasUnmanagedTypeConstraint)
                constraintClauses.Add("struct");
            if (tp.HasConstructorConstraint)
                constraintClauses.Add("new()");

            foreach (var t in tp.ConstraintTypes)
            {
                constraintClauses.Add(t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            }
            if (constraintClauses.Count > 0)
            {
                sbConstraints.AppendLine($" where {tp.Name} : {string.Join(", ", constraintClauses)}");
            }
        }
        constraints = sbConstraints.ToString();
        return $"{GetAccessibility(typeSymbol)} class {typeSymbol.Name}{tpList}";
    }

    private static string GetAccessibility(INamedTypeSymbol typeSymbol)
    {
        return typeSymbol.DeclaredAccessibility.ToString().ToLower();
    }

    // For nested types, gather chain outward to get partial signatures
    private static List<(string Declaration, INamedTypeSymbol Symbol)> GetContainingTypes(INamedTypeSymbol typeSymbol)
    {
        var result = new List<(string Declaration, INamedTypeSymbol Symbol)>();
        var current = typeSymbol.ContainingType;
        while (current != null)
        {
            // build partial class or struct or record, etc.
            // for simplicity, assume partial class
            var dec = $"{GetAccessibility(current)} partial class {current.Name}";
            result.Add((dec, current));
            current = current.ContainingType;
        }
        result.Reverse();
        return result;
    }

    private static string GetSafeFileName(string name)
    {
        // remove invalid chars
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        foreach (var c in invalid)
        {
            name = name.Replace(c, '_');
        }
        return name;
    }

    private const string EmbeddedAttributeSource = @"// <auto-generated/>
using System;

enum CommandCreationType
{
    Create,
    FromTask,
    FromObservable
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
sealed class GenerateCommandAttribute : Attribute
{
    public string? CommandName { get; set; }
    public string? CanExecuteProperty { get; set; }
    public CommandCreationType? CommandType { get; set; }
    public Type? ParameterType { get; set; }
}
";
}
